//========================================================================//
//  Cookie library                                                        //
//========================================================================//
/* Instructions to supress js hint errors */
/* exported createCookie */
/* exported readCookie */
/* exported eraseCookie */

/**
 * Creates a cookie.
 * @param string name
 * @param string value
 * @param int days
 */
function createCookie(name, value, days, path) {
  path = path || '/';
  var expires = "";
  
  if (days) {
    var date = new Date();
    date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
    expires = "; expires=" + date.toGMTString();
  }
  
  document.cookie = name + "=" + value + expires + "; path=" + path;
}

/**
 * Reads a cookie value with the given name.
 * @param string name
 * @return mixed
 *   Cookie value or null.
 */
function readCookie(name) {
  var nameEQ = name + "=";
  var ca = document.cookie.split(';');
  for (var i = 0; i < ca.length; i++) {
    var c = ca[i];
    while (c.charAt(0) == ' ')
    c = c.substring(1, c.length);
    if (c.indexOf(nameEQ) === 0)
      return c.substring(nameEQ.length, c.length);
  }
  return null;
}

/**
 * Deletes a cookie with the given name.
 * @param string name
 */
function eraseCookie(name, path) {
  path = path || '/';
  createCookie(name, "", -1, path);
}
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
/* jshint unused: false */
function debounce(func, wait, immediate) {
  var timeout;
  return function() {
    var context = this, args = arguments;
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    }, wait);
    if (immediate && !timeout) func.apply(context, args);
  };
}

// Table row slideUp and slideDown.
// This is not a general approach as it only works for the states
// because you have two tr inside a tbody.
(function($) {
  $.fn.trSlideUp = function() {
    return this.filter('tr').each(function() {
      var _self = $(this);

      _self.children("td").each(function() {
        if ($(this).children("div.tr-slide-wrapper").length === 0) {
          $(this).wrapInner("<div class='tr-slide-wrapper'></div>");
        }
        $(this).children("div.tr-slide-wrapper").slideUp(function() {
          _self.hide();
        });
      });
    });
  };

  $.fn.trSlideDown = function() {
    return this.filter('tr').each(function() {
      var _self = $(this);
      _self.show();

      _self.children("td").each(function() {
        if ($(this).children("div.tr-slide-wrapper").length === 0) {
          // If the wrapping is done before showing the data, the divs
          // must be hidden.
          $(this).wrapInner("<div class='tr-slide-wrapper' style='display: none'></div>");
        }
        $(this).children("div.tr-slide-wrapper").slideDown();
      });
    });
  };
})(jQuery);

// Rounds the given number.
// From http://www.jacklmoore.com/notes/rounding-in-javascript/
/* jshint unused: false */
function round(value, decimals) {
    return Number(Math.round(value+'e'+decimals)+'e-'+decimals);
}
$(document).ready(function() {

  var rank = function () {

    var mapSettings = {
      'world': {
        mapId: 'flipside.e6958sxs',
        zoom: 2,
        center: [0, 0]
      },
      'africa': {
        mapId: 'flipside.cdw17lf8',
        zoom: 3,
        center: [-9.6224, 25.8398]
      },
      'asia': {
        mapId: 'flipside.j7e3okc6',
        zoom: 3,
        center: [20.63278, 104.0625]
      },
      'lac': {
        mapId: 'flipside.b1dsv657',
        zoom: 2,
        center: [-15.6230, -59.0625]
      }
    };
    var mapConf = CS.regionId ?  mapSettings[CS.regionId] : mapSettings.world;
    var map = L.mapbox.map('index-viz', mapConf.mapId, {
                          minZoom: 2,
                          maxBounds: [
                            [84.812743, -178.629215],
                            [-78.229733, 179.964543]
                          ],
                          tileLayer: {
                            continuousWorld: false,
                            noWrap: true
                          }
    }).setView(mapConf.center, mapConf.zoom);

    var point = function(x, y) {
      var pt = map.latLngToLayerPoint([y, x]);
      this.stream.point(pt.x, pt.y);
    };

    var projection = d3.geo.transform({point: point});

    var path = d3.geo.path().projection(projection);

    var tooltip = d3.tip().attr('class', 'tooltip-map top')
      .attr('id', 'index-viz-tooltip')
      .html(function(d) {

        d = d.rank;
        var link_text, close_text, rank_text, score_text;

        switch(CS.lang) {
          case 'en':
            link_text = "View Country";
            close_text = "Close";
            rank_text = "Rank";
            score_text = "Score";
            grid_on_text = "On-grid";
            grid_off_text = "Off-grid";
          break;
          case 'es':
            link_text = "Ver País";
            close_text = "Cerrar";
            rank_text = "Posición";
            score_text = "Puntaje";
            grid_on_text = "On-grid ES";
            grid_off_text = "Off-grid ES";
          break;
        }

        var param_code = '';
        $.each(d.parameters, function(index, param) {
          var className = 'param-' + param.id;
          param_code += [
            '<dt class="' + className + '">' + param.name + '</dt>',
            '<dd>',
              round(param.value, 2),
              '<small>' + round(param.weight * 100, 2) + '%' + '</small>',
            '</dd>',
          ].join(' ');
        });

        var grid_code = d.grid == 'on' ? '<em class="label-grid label-grid-on" data-title="' + grid_on_text + '"><span>' + grid_on_text + '</span></em>' : '<em class="label-grid label-grid-off" data-title="' + grid_off_text + '"><span>' + grid_off_text + '</span></em>';

        return [
          '<article class="tooltip-inner">',
            '<header class="tooltip__header">',
              '<h1 class="tooltip__title"><a href="' + CS.countryIndex[d.iso] +'" title="' + link_text + '">' + d.name + '</a></h1>',
              '<p class="tooltip__subtitle">' + d.region.name + '</p>',
              grid_code,
              '<a href="#" title="' + close_text + '" class="close" onClick="return false;"><span>' + close_text + '</span></a>',
            '</header>',

            '<div class="tooltip__body">',
              '<dl class="params-legend">',
                '<dt>' + rank_text + '</dt>',
                '<dd>' + d.overall_ranking + '</dd>',
                '<dt>' + score_text + '</dt>',
                '<dd>' + round(d.score, 2) + '</dd>',
                param_code,
              '</dl>',
              '<a href="' + CS.countryIndex[d.iso] +'" class="bttn bttn-cta go" title="' + link_text + '">' + link_text + '</a>',
            '</div>',

          '</article>'
        ].join(' ');
    }); // end tooltip html fn

    // UI element for toggling the map
    var $countryFilter = $('<div>', {
        'class': 'leaflet-control bttn-group bttn-group-s bttn-list map-country-toggle'
    });
    var svg = d3.select(map.getPanes().overlayPane)
      .append('svg:svg')
      .call(tooltip);
    var g = svg.append('svg:g').attr('class', 'leaflet-zoom-hide');

    // placeholder variables to query via http request
    var land;
    var indicators;

    // object of svg markers to move on map viewreset
    var markers = {
      highlight: [],
      countries: []
    }

    // 1: top ten; -1: bottom ten; 0: all
    var countryFilter = [
      'top-ten',
      'bottom-ten'
    ];
    var visibleCountries = 'top-ten';
    var zoom = map.getZoom();

    var undef = void 0;

    var countryListUrl = CS.domain + '/' + CS.lang + '/api/countries.json';
    if (CS.regionId) {
      countryListUrl = CS.domain + '/' + CS.lang + '/api/regions/' + CS.regionId + '.json';
    }

    // two switches to detect whether marker is clicked,
    // and whether mouse is over tooltip
    var clicked = false;
    var mouseInFeature = false;

    // allRanking is true when everything is ranked
    // this happens at zoom levels larger than allRankingLevel
    var allRanking = false;
    var allRankingLevel = 3;

    queue()
    // The topo json file is the same for all languages.
    //.defer(d3.json, CS.domain + '/en/api/countries.topojson')
    .defer(d3.json, CS.domain + '/en/api/centroids.topojson')
    .defer(d3.json, countryListUrl)

    // these are used for local testing only - Derek
    // .defer(d3.json, 'en/api/countries.topojson')
    // .defer(d3.json, 'en/api/countries.json')
    .await(function(error, geography, countryRank) {
      land = topojson.feature(geography, geography.objects.centroids).features;

      // If there's a region, the countries are inside an object.
      indicators = CS.regionId ? countryRank.countries : countryRank;

      // Sort parameters.
      $.each(indicators, function(index, country) {
        country.parameters.sort(function(a, b) {
          return a.id > b.id;
        });
      });

      var lookup = {};
      var max = [];
      var filtered = [];
      var iso;

      // create a look-up table for each indicator by country code
      // also get a list of each overall ranking to create color scale
      for (var i = 0, ii = indicators.length; i < ii; ++i) {
        lookup[indicators[i].iso] = i;
        max.push(indicators[i].overall_ranking);
      }

      // using lookup, filter out geographies that don't have data;
      // join indicator data to countries with data
      for (i = 0, ii = land.length; i < ii; ++i) {
        iso = land[i].id;
        if (lookup[iso] !== undef) {
          land[i].rank = indicators[lookup[iso]];
          land[i].d = land[i].rank.overall_ranking;
          land[i].parameters = {};

          // create an object as a property of rank
          // object keys are ids of parameters
          for(var k = 0; k < 4; ++k) {
            land[i].parameters[
              land[i].rank.parameters[k].id
            ] = land[i].rank.parameters[k];
          }

          filtered.push(land[i]);
        }
      }

      land = filtered.sort(function(a, b) { return a.d - b.d; });
      resetSVG();
      redrawMarkers({reset: true});

      // creating the country filter
      $countryFilter.on('click', 'button', function(e) {

        var cls = e.currentTarget.className;
        var toShow = cls.slice(cls.indexOf('show') + 5);

        if (visibleCountries === toShow) return;  // ignore if already showing

        visibleCountries = toShow;
        $countryFilter.find('.active').removeClass('active');
        e.currentTarget.className = 'active ' + cls;  // selection class

        redrawMarkers({rankOnly: true });
      });

      // Creating each button, making top-ten the first active button
      $.each(countryFilter, function(index, key) {
        var cls = 'bttn bttn-default show-' + key;
        if (key === 'top-ten') {
          cls = 'active ' + cls;
        }
        $('<button>', { 'type': 'button', 'class': cls, 'text': key.split('-').join(' ')})
          .appendTo($countryFilter);
      });

      $countryFilter.appendTo($('.leaflet-bottom.leaflet-left'));

      // if someone moves their mouse from a marker to the tooltip,
      // marker hands off the responsibility of closing the tooltip
      // to the tooltip itself
      var $tooltip = $('#index-viz-tooltip');
      $tooltip.on('mouseenter', function() {
        mouseInFeature = true;
      })
      .on('mouseleave', function() {
        mouseInFeature = false;
        if (!clicked) {
          tooltip.hide();
        }
      })
      .on('click', '.close', function() {
        tooltip.hide();
        mouseInFeature = false;
      });
    });

    // resetSVG alters the SVG bounds when map changes
    // It does NOT alter the locations of markers.
    function resetSVG() {
      var bounds = path.bounds({type: 'FeatureCollection', features: land});
      var topLeft = bounds[0];
      var bottomRight = bounds[1];
      var transform = [-topLeft[0] + 50, -topLeft[1] + 50];

      svg.attr('width', bottomRight[0] - topLeft[0] + 100)
        .attr('height', bottomRight[1] - topLeft[1] + 100)
        .style('left', topLeft[0]-50 + 'px')
        .style('top', topLeft[1]-50 + 'px');

      g.attr('transform', 'translate(' + transform[0] + ',' + transform[1] + ')');
    }

    function redrawMarkers(options) {

      // full reset; draws all countries as country-markers,
      // then draws highlighted rank markers on top.
      if (options.reset) {
        g.selectAll('g').remove();
        markers.countries = drawCountries(land, '');
        markers.highlight = drawRanking(getSlice(visibleCountries), ' highlight');
      }

      // only draw rankings;
      // used when someone changes the top-/bottom-ten toggle,
      // and we're still drawing country markers as un-ranked (higher zoom levels)
      else if (options.rankOnly && !allRanking) {
        g.selectAll('.rank-marker').remove();
        markers.highlight = drawRanking(getSlice(visibleCountries), ' highlight');
      }

      // this is used for all draws in which all countries show rank (lower zooms)
      else if ((options.rankOnly && allRanking) || options.rankAll) {
        g.selectAll('g').remove();
        markers.countries = drawRanking(land, '');
        markers.highlight = drawRanking(getSlice(visibleCountries), ' highlight');
      }
    }

    function drawCountries(countries, cls) {
      var marker = drawMarker(countries, 'country-marker' + cls, 5)
      marker.transition()
          .delay(700)
          .duration(200)
          .style('opacity', 1);
      return marker;
    }

    function drawRanking(highlighted, cls) {
      var marker = drawMarker(highlighted, 'rank-marker' + cls, 16);
      marker.append('text')
        .attr('dy', '6px')
        .text(function(d) { return d.d < 10 ? '0' + d.d : d.d; });
      marker.transition()
        .delay(function(d, i) { return 200 + i * 20; })
        .duration(200)
        .style('opacity', 1);
      return marker;
    }

    function drawMarker(data, cls, radius) {
      var markers = g.selectAll('.' + cls)
        .data(data)
      .enter().append('g')
        .attr('class', cls)
        .style('opacity', 0)
        .attr('transform', function(d) {
          var coords = map.latLngToLayerPoint([
            d.geometry.coordinates[1],
            d.geometry.coordinates[0]
          ]);
          return 'translate(' + coords.x + ',' + coords.y + ')';
        })

        .on('mouseover', function(d) {
          mouseInFeature = true;
          if (!clicked) { tooltip.show(d); }
        })

        .on('mouseout', function() {
          mouseInFeature = false;
          if (!clicked) {
            window.setTimeout(function() {
              if (!mouseInFeature) {
                tooltip.hide();
              }
            }, 300);
          }
        })

        .on('click', function(d) {
          clicked = true;
          tooltip.show(d);
          // close tooltip on next click, unless it's on another circle el
          window.setTimeout(function() {
            $(document).one('click', function(e) {
              if (e.target.localName !== 'circle') {
                clicked = false;
                tooltip.hide();
              }
            });
          }, 100);
        })

      markers.append('circle')
        .attr('r', radius);

      return markers;
    }

    function getSlice(visible) {
      return visible === 'top-ten' ?
        land.slice(0, 10) : visible === 'bottom-ten' ?
        land.slice(-10) : land;
    }

    map.on('dragstart', function() {
      tooltip.hide();
    });

    map.on('viewreset', function() {
      resetSVG();
      zoom = map.getZoom();

      // we've zoomed in and need to show all markers as ranks
      if (zoom > allRankingLevel && !allRanking) {
        allRanking = true;
        $countryFilter.addClass('disabled');
        g.selectAll('.country-marker').remove();
        redrawMarkers({rankAll: true});
      }

      else if (zoom <= allRankingLevel && allRanking) {
        allRanking = false;
        $countryFilter.removeClass('disabled');
        g.selectAll('.rank-marker').remove();
        redrawMarkers({reset: true});
      }

      else {
        for (var key in markers) {
          markers[key].attr('transform', function(d) {
            var coords = map.latLngToLayerPoint([
              d.geometry.coordinates[1],
              d.geometry.coordinates[0]
            ]);
            return 'translate(' + coords.x + ',' + coords.y + ')';
          });
        }
      }
      tooltip.hide();
    });

    // listening for weight changer changes
    var updateSliders = debounce(function(e, weight) {
      var keys = $.map(land[0].rank.parameters, function(d) { return d.id; });
      for(var d = {}, i = 0, ii = land.length; i < ii; ++i) {
        d = land[i].parameters;

        land[i].rank.score = (Math.round(
          weight['param-' + keys[0]] * d[keys[0]].value +
          weight['param-' + keys[1]] * d[keys[1]].value +
          weight['param-' + keys[2]] * d[keys[2]].value +
          weight['param-' + keys[3]] * d[keys[3]].value
                                        )) / 100;
      }
      land = land.sort(function(a, b) { return b.rank.score - a.rank.score; });
      for(i = 0; i < ii; ++i) {
        land[i].d = land[i].rank.overall_ranking = i + 1;
      }

      redrawMarkers({rankOnly: true });
    }, 100, false);

    $('.slider-group').on('update-sliders', updateSliders);
  };


  // Since the map holder is index-viz check if it exists.
  // if false, probably isn't the index page so do nothing
  var parent = document.querySelector('#index-viz');
  if (!parent) {
    return;
  }
  // load the map
  else {
    new rank();
  }
});

function initDropdown() {
  $('[data-toggle="dropdown"]').once('dropdown').click(function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    var parent = $(this).parent('.dropdown');
    parent.toggleClass('open');
    
    $('.dropdown.open').not(parent).removeClass('open');
  });
  
  $('body').once('dropdown', function() {
    $(document).click(function() {
      $('.dropdown.open').removeClass('open');
    });
  });
  
}

$(function() {
  initDropdown();
  
  // Modal cookie.
  // Only show modal the first time the user enters the page.
  // It will be language dependent.
  if (readCookie('welcome_modal') != 'hide') {
    $('#welcome').addClass('revealed');
  }
  
  $('#welcome [data-modal-dismiss]').click(function(e) {
    e.preventDefault();
    createCookie('welcome_modal', 'hide', 10, CS.domain + '/' + CS.lang);
  });
  
  $('#welcome.modal').click(function(e) {
    // Prevent children from triggering this.
    if(e.target == e.currentTarget) {
      createCookie('welcome_modal', 'hide', 10, CS.domain + '/' + CS.lang);
    }
  });
  
});

$(document).ready(function() {

  // Stop here if the parameters do not exist.
  if ($('#parameters-controls').length === 0) {
    return;
  }

  var header_height = $('#site-header').outerHeight();

  var check_sticky = function() {
     if ($(document).scrollTop() >= header_height) {
       if (!$('#parameters-controls').hasClass('sticky')) {
         $('#parameters-controls').addClass('sticky');
         check_sticky_padding();
       }
     }
     else {
       $('#parameters-controls').removeClass('sticky');
       check_sticky_padding();
     }
  };

  // When the parameter controls become sticky
  // its height must be added as a padding to the parent
  // to make up for its absence.
  var check_sticky_padding = function() {
    var parameter_controls = $('#parameters-controls');
    if (parameter_controls.css('position') == 'fixed') {
      var parameter_height = parameter_controls.outerHeight();
      parameter_controls.parent().css('padding-top', parameter_height);
    }
    else {
      parameter_controls.parent().css('padding-top', 0);
    }
  };

  // Setup listeners.
  $(document).on('scroll', check_sticky);
  $(window).on('resize', debounce(function() {
    header_height = $('#site-header').outerHeight();
    check_sticky_padding();
  }, 50));

  check_sticky();

  var appElement = document.querySelector('[ng-app=countryListApp]');
  var countryAppScope = angular.element(appElement).scope();
  // Slider group for homepage.
  $('.slider-group').sliderGroup({
    start: 25,
    range: {
      'min': 0,
      'max': 100
    },
    connect: "lower",
    step: 1,
    animate: false
  })
  .on('update-sliders', function(event, data) {
    // Get inside angular scope.
    countryAppScope.$apply(function() {
      var countries = countryAppScope.countryTable.countries;

      // Helper functions.
      // Update parameters and return new global score.
      var updateParams = function(params) {
        var globalScore = 0;
        angular.forEach(params, function(param) {
          // Update param weight.
          param.weight = data['param-' + param.id] / 100;
          // Country score.
          globalScore += (param.weight * param.value);
        });
        return round(globalScore, 5);
      };

      // Update country scores.
      angular.forEach(countries, function(country) {
        // Update params and calc score.
        var newCountryScore = updateParams(country.parameters);
        // Set country score.
        country.score = newCountryScore;
      });

      // Sort Countries
      countries.sort(function(a, b) {
        return b.score - a.score;
      });

      // Based on the array order update the overall ranking.
      angular.forEach(countries, function(country, key) {
        country.overall_ranking = key + 1;

        // Do everything done to countries to the states.
        if (!country.states) {
          return;
        }
        // --- States ---
        angular.forEach(country.states, function(state) {
          // Update params and calc score.
          var newStateScore = updateParams(state.parameters);
          // Set state score.
          state.score = newStateScore;
        });
        // Sort states.
        country.states.sort(function(a, b) {
          return b.score - a.score;
        });
        // Based on the array order set the overall ranking.
        angular.forEach(country.states, function(state, key) {
          state.state_ranking = key + 1;
        });
        // --- END States ---

      });

    });

    // Temp data!
    $('.slider-value.param-1').text(data['param-1'] + '%');
    $('.slider-value.param-2').text(data['param-2'] + '%');
    $('.slider-value.param-3').text(data['param-3'] + '%');
    $('.slider-value.param-4').text(data['param-4'] + '%');
  });
  
  // Reset button.
  $('#vis-controls .reset').click(function(e) {
    e.preventDefault();
    $('#vis-controls.slider-group').sliderGroup('reset');
  });
  
});

// http://unheap.com
$(function() {
  $('.browsehappy').on('click', function() {
  $(this).slideUp('fast');
  });
});

// Modals
(function($) {

  $(function() {
  
    $('[data-modal-id]').click(function(e) {
      e.preventDefault();
      var id = $(this).attr('data-modal-id');
      
      $('#' + id).addClass('revealed');
    });
    
    $('.modal').click(function(e) {
      // Prevent children from triggering this.
      if(e.target == e.currentTarget) {
        $(this).removeClass('revealed');
      }
    });

    $('[data-modal-dismiss]').click(function(e) {
        e.preventDefault();
        $(this).closest('.modal').removeClass('revealed');
    });

  });

})(jQuery);
/*
 * SliderGroup plugin.
 * 
 * Makes all the sliders in a group interconnect.
 * Depends on noUiSlider.
 * 
 * $('.slider-group').sliderGroup(options);
 * 
 * The options are the same as used by noUiSlider.
 */
(function($) {
  
  function sliderGroup(options) {
    var $group = $(this);
    var sliders = $('.slider', $group);

    // Returns the sum of all the slider's values.
    var getGroupTotal = function() {
      var total = 0;
      sliders.each(function() {
        total += parseFloat($(this).val());
      });
      return total;
    };

    // Gets the slider's data prepared to send to the listener.
    var getSlidersData = function() {
      var data = {};
      sliders.each(function(index) {
        var id = $(this).attr('id') || index;
        data[id] = parseFloat($(this).val());
      });
      return data;
    };

    // Sets the slider's defaults using the data attribute.
    var setSlidersDefaultValues = function() {
      sliders.each(function() {
        var starting = $(this).attr('data-starting');
        if (!starting) {
          throw Error("sliderGroup: missing 'data-starting' attribute.");
        }
         $(this).val($(this).attr('data-starting'));
      });

      // Send data to event listener as init.
      var data = getSlidersData();
      $group.trigger('update-sliders', [data]);
    };
    
    // Reset Option.
    if (options == 'reset') {
      setSlidersDefaultValues();
      // Unlock.
      sliders.siblings('.lock').find('.switch-checkbox').removeAttr('checked').trigger('change');
      return this;
    }

    // Initialize all sliders.
    sliders.noUiSlider(options);
    setSlidersDefaultValues();
    
    // When setting up the slider the listener is not yet attached
    // to the slider group, so the trigger wouldn't work.
    // By delaying the execution a few millis there is time for the
    // listener to be attached.
    // An alternative to this would be to have a init function callback
    // but let's pick one and go with it.
    setTimeout(function() {
      var data = getSlidersData();
      $group.trigger('update-sliders', [data]);
    }, 10);
    

    sliders.on('slide', function() {
      var _self = this;
      var _selfValue = parseFloat($(this).val());

      // Get total for all sliders.
      var total = getGroupTotal();

      // Get by how much is over 100;
      var delta = 100 - total;

      // Sliders to update. Everyone except the disabled ones and the current.
      var slidersToChange = sliders.not(_self).not('[disabled]');
      var countSliders = slidersToChange.length;

      slidersToChange.each(function() {
        var value = parseFloat($(this).val());
        var new_value = value + (delta / countSliders);
        
        if (new_value < 0 || _selfValue == 100) {
          new_value = 0;
        }
        if (new_value > 100) {
          new_value = 100;
        }
        $(this).val(new_value);
      });

      // Get the updated value of the sliders.
      var updatedTotal = getGroupTotal();
      // Value for other slides.
      var updatedOthersTotal = updatedTotal - _selfValue;

      // Prevent the current slide from going over 100.
      if (updatedTotal != 100) {
        $(_self).val(100 - updatedOthersTotal);
      }

      // Prepare data to send to event listener.  
      var data = getSlidersData();      
      $group.trigger('update-sliders', [data]);
      
    });

    // Initialize locks.
    sliders.each(function() {
      var $slider = $(this);
      // Search for a sibling lock.
      $slider.siblings('.lock').find('.switch-checkbox').change(function() {
        if ($(this).is(':checked')) {
          $slider.attr('disabled', 'disabled');
        }
        else {
          $slider.removeAttr('disabled');
        }
      });
    });
    
    return this;
  }

  $.fn.sliderGroup = function(options) {    
    return this.each(function() {
      return sliderGroup.apply(this, [options]);
    });
  };
  
})(jQuery);
/*
 * angular-ui-bootstrap
 * http://angular-ui.github.io/bootstrap/

 * Version: 0.10.0 - 2014-02-05
 * License: MIT
 */
angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.pagination","ui.bootstrap.position","ui.bootstrap.bindHtml","ui.bootstrap.tooltip","ui.bootstrap.popover"]);
angular.module("ui.bootstrap.tpls", ["template/pagination/pager.html","template/pagination/pagination.html","template/tooltip/tooltip-html-unsafe-popup.html","template/tooltip/tooltip-popup.html","template/popover/popover.html"]);
angular.module('ui.bootstrap.pagination', [])

.controller('PaginationController', ['$scope', '$attrs', '$parse', '$interpolate', function ($scope, $attrs, $parse, $interpolate) {
  var self = this,
      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;

  this.init = function(defaultItemsPerPage) {
    if ($attrs.itemsPerPage) {
      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
        self.itemsPerPage = parseInt(value, 10);
        $scope.totalPages = self.calculateTotalPages();
      });
    } else {
      this.itemsPerPage = defaultItemsPerPage;
    }
  };

  this.noPrevious = function() {
    return this.page === 1;
  };
  this.noNext = function() {
    return this.page === $scope.totalPages;
  };

  this.isActive = function(page) {
    return this.page === page;
  };

  this.calculateTotalPages = function() {
    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
    return Math.max(totalPages || 0, 1);
  };

  this.getAttributeValue = function(attribute, defaultValue, interpolate) {
    return angular.isDefined(attribute) ? (interpolate ? $interpolate(attribute)($scope.$parent) : $scope.$parent.$eval(attribute)) : defaultValue;
  };

  this.render = function() {
    this.page = parseInt($scope.page, 10) || 1;
    if (this.page > 0 && this.page <= $scope.totalPages) {
      $scope.pages = this.getPages(this.page, $scope.totalPages);
    }
  };

  $scope.selectPage = function(page) {
    if ( ! self.isActive(page) && page > 0 && page <= $scope.totalPages) {
      $scope.page = page;
      $scope.onSelectPage({ page: page });
    }
  };

  $scope.$watch('page', function() {
    self.render();
  });

  $scope.$watch('totalItems', function() {
    $scope.totalPages = self.calculateTotalPages();
  });

  $scope.$watch('totalPages', function(value) {
    setNumPages($scope.$parent, value); // Readonly variable

    if ( self.page > value ) {
      $scope.selectPage(value);
    } else {
      self.render();
    }
  });
}])

.constant('paginationConfig', {
  itemsPerPage: 10,
  boundaryLinks: false,
  directionLinks: true,
  firstText: 'First',
  previousText: 'Previous',
  nextText: 'Next',
  lastText: 'Last',
  rotate: true
})

.directive('pagination', ['$parse', 'paginationConfig', function($parse, config) {
  return {
    restrict: 'EA',
    scope: {
      page: '=',
      totalItems: '=',
      onSelectPage:' &'
    },
    controller: 'PaginationController',
    templateUrl: 'template/pagination/pagination.html',
    replace: true,
    link: function(scope, element, attrs, paginationCtrl) {

      // Setup configuration parameters
      var maxSize,
      boundaryLinks  = paginationCtrl.getAttributeValue(attrs.boundaryLinks,  config.boundaryLinks      ),
      directionLinks = paginationCtrl.getAttributeValue(attrs.directionLinks, config.directionLinks     ),
      firstText      = paginationCtrl.getAttributeValue(attrs.firstText,      config.firstText,     true),
      previousText   = paginationCtrl.getAttributeValue(attrs.previousText,   config.previousText,  true),
      nextText       = paginationCtrl.getAttributeValue(attrs.nextText,       config.nextText,      true),
      lastText       = paginationCtrl.getAttributeValue(attrs.lastText,       config.lastText,      true),
      rotate         = paginationCtrl.getAttributeValue(attrs.rotate,         config.rotate);

      paginationCtrl.init(config.itemsPerPage);

      if (attrs.maxSize) {
        scope.$parent.$watch($parse(attrs.maxSize), function(value) {
          maxSize = parseInt(value, 10);
          paginationCtrl.render();
        });
      }

      // Create page object used in template
      function makePage(number, text, isActive, isDisabled) {
        return {
          number: number,
          text: text,
          active: isActive,
          disabled: isDisabled
        };
      }

      paginationCtrl.getPages = function(currentPage, totalPages) {
        var pages = [];

        // Default page limits
        var startPage = 1, endPage = totalPages;
        var isMaxSized = ( angular.isDefined(maxSize) && maxSize < totalPages );

        // recompute if maxSize
        if ( isMaxSized ) {
          if ( rotate ) {
            // Current page is displayed in the middle of the visible ones
            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);
            endPage   = startPage + maxSize - 1;

            // Adjust if limit is exceeded
            if (endPage > totalPages) {
              endPage   = totalPages;
              startPage = endPage - maxSize + 1;
            }
          } else {
            // Visible pages are paginated with maxSize
            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;

            // Adjust last page if limit is exceeded
            endPage = Math.min(startPage + maxSize - 1, totalPages);
          }
        }

        // Add page number links
        for (var number = startPage; number <= endPage; number++) {
          var page = makePage(number, number, paginationCtrl.isActive(number), false);
          pages.push(page);
        }

        // Add links to move between page sets
        if ( isMaxSized && ! rotate ) {
          if ( startPage > 1 ) {
            var previousPageSet = makePage(startPage - 1, '...', false, false);
            pages.unshift(previousPageSet);
          }

          if ( endPage < totalPages ) {
            var nextPageSet = makePage(endPage + 1, '...', false, false);
            pages.push(nextPageSet);
          }
        }

        // Add previous & next links
        if (directionLinks) {
          var previousPage = makePage(currentPage - 1, previousText, false, paginationCtrl.noPrevious());
          pages.unshift(previousPage);

          var nextPage = makePage(currentPage + 1, nextText, false, paginationCtrl.noNext());
          pages.push(nextPage);
        }

        // Add first & last links
        if (boundaryLinks) {
          var firstPage = makePage(1, firstText, false, paginationCtrl.noPrevious());
          pages.unshift(firstPage);

          var lastPage = makePage(totalPages, lastText, false, paginationCtrl.noNext());
          pages.push(lastPage);
        }

        return pages;
      };
    }
  };
}])

.constant('pagerConfig', {
  itemsPerPage: 10,
  previousText: '« Previous',
  nextText: 'Next »',
  align: true
})

.directive('pager', ['pagerConfig', function(config) {
  return {
    restrict: 'EA',
    scope: {
      page: '=',
      totalItems: '=',
      onSelectPage:' &'
    },
    controller: 'PaginationController',
    templateUrl: 'template/pagination/pager.html',
    replace: true,
    link: function(scope, element, attrs, paginationCtrl) {

      // Setup configuration parameters
      var previousText = paginationCtrl.getAttributeValue(attrs.previousText, config.previousText, true),
      nextText         = paginationCtrl.getAttributeValue(attrs.nextText,     config.nextText,     true),
      align            = paginationCtrl.getAttributeValue(attrs.align,        config.align);

      paginationCtrl.init(config.itemsPerPage);

      // Create page object used in template
      function makePage(number, text, isDisabled, isPrevious, isNext) {
        return {
          number: number,
          text: text,
          disabled: isDisabled,
          previous: ( align && isPrevious ),
          next: ( align && isNext )
        };
      }

      paginationCtrl.getPages = function(currentPage) {
        return [
          makePage(currentPage - 1, previousText, paginationCtrl.noPrevious(), true, false),
          makePage(currentPage + 1, nextText, paginationCtrl.noNext(), false, true)
        ];
      };
    }
  };
}]);

angular.module('ui.bootstrap.position', [])

/**
 * A set of utility methods that can be use to retrieve position of DOM elements.
 * It is meant to be used where we need to absolute-position DOM elements in
 * relation to other, existing elements (this is the case for tooltips, popovers,
 * typeahead suggestions etc.).
 */
  .factory('$position', ['$document', '$window', function ($document, $window) {

    function getStyle(el, cssprop) {
      if (el.currentStyle) { //IE
        return el.currentStyle[cssprop];
      } else if ($window.getComputedStyle) {
        return $window.getComputedStyle(el)[cssprop];
      }
      // finally try and get inline style
      return el.style[cssprop];
    }

    /**
     * Checks if a given element is statically positioned
     * @param element - raw DOM element
     */
    function isStaticPositioned(element) {
      return (getStyle(element, "position") || 'static' ) === 'static';
    }

    /**
     * returns the closest, non-statically positioned parentOffset of a given element
     * @param element
     */
    var parentOffsetEl = function (element) {
      var docDomEl = $document[0];
      var offsetParent = element.offsetParent || docDomEl;
      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || docDomEl;
    };

    return {
      /**
       * Provides read-only equivalent of jQuery's position function:
       * http://api.jquery.com/position/
       */
      position: function (element) {
        var elBCR = this.offset(element);
        var offsetParentBCR = { top: 0, left: 0 };
        var offsetParentEl = parentOffsetEl(element[0]);
        if (offsetParentEl != $document[0]) {
          offsetParentBCR = this.offset(angular.element(offsetParentEl));
          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
        }

        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop('offsetWidth'),
          height: boundingClientRect.height || element.prop('offsetHeight'),
          top: elBCR.top - offsetParentBCR.top,
          left: elBCR.left - offsetParentBCR.left
        };
      },

      /**
       * Provides read-only equivalent of jQuery's offset function:
       * http://api.jquery.com/offset/
       */
      offset: function (element) {
        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop('offsetWidth'),
          height: boundingClientRect.height || element.prop('offsetHeight'),
          top: boundingClientRect.top + ($window.pageYOffset || $document[0].body.scrollTop || $document[0].documentElement.scrollTop),
          left: boundingClientRect.left + ($window.pageXOffset || $document[0].body.scrollLeft  || $document[0].documentElement.scrollLeft)
        };
      }
    };
  }]);

angular.module('ui.bootstrap.bindHtml', [])

  .directive('bindHtmlUnsafe', function () {
    return function (scope, element, attr) {
      element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);
      scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
        element.html(value || '');
      });
    };
  });
/**
 * The following features are still outstanding: animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html tooltips, and selector delegation.
 */
angular.module( 'ui.bootstrap.tooltip', [ 'ui.bootstrap.position', 'ui.bootstrap.bindHtml' ] )

/**
 * The $tooltip service creates tooltip- and popover-like directives as well as
 * houses global options for them.
 */
.provider( '$tooltip', function () {
  // The default options tooltip and popover.
  var defaultOptions = {
    placement: 'top',
    animation: true,
    popupDelay: 0
  };

  // Default hide triggers for each show trigger
  var triggerMap = {
    'mouseenter': 'mouseleave',
    'click': 'click',
    'focus': 'blur'
  };

  // The options specified to the provider globally.
  var globalOptions = {};
  
  /**
   * `options({})` allows global configuration of all tooltips in the
   * application.
   *
   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
   *     // place tooltips left instead of top by default
   *     $tooltipProvider.options( { placement: 'left' } );
   *   });
   */
	this.options = function( value ) {
		angular.extend( globalOptions, value );
	};

  /**
   * This allows you to extend the set of trigger mappings available. E.g.:
   *
   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );
   */
  this.setTriggers = function setTriggers ( triggers ) {
    angular.extend( triggerMap, triggers );
  };

  /**
   * This is a helper function for translating camel-case to snake-case.
   */
  function snake_case(name){
    var regexp = /[A-Z]/g;
    var separator = '-';
    return name.replace(regexp, function(letter, pos) {
      return (pos ? separator : '') + letter.toLowerCase();
    });
  }

  /**
   * Returns the actual instance of the $tooltip service.
   * TODO support multiple triggers
   */
  this.$get = [ '$window', '$compile', '$timeout', '$parse', '$document', '$position', '$interpolate', function ( $window, $compile, $timeout, $parse, $document, $position, $interpolate ) {
    return function $tooltip ( type, prefix, defaultTriggerShow ) {
      var options = angular.extend( {}, defaultOptions, globalOptions );

      /**
       * Returns an object of show and hide triggers.
       *
       * If a trigger is supplied,
       * it is used to show the tooltip; otherwise, it will use the `trigger`
       * option passed to the `$tooltipProvider.options` method; else it will
       * default to the trigger supplied to this directive factory.
       *
       * The hide trigger is based on the show trigger. If the `trigger` option
       * was passed to the `$tooltipProvider.options` method, it will use the
       * mapped trigger from `triggerMap` or the passed trigger if the map is
       * undefined; otherwise, it uses the `triggerMap` value of the show
       * trigger; else it will just use the show trigger.
       */
      function getTriggers ( trigger ) {
        var show = trigger || options.trigger || defaultTriggerShow;
        var hide = triggerMap[show] || show;
        return {
          show: show,
          hide: hide
        };
      }

      var directiveName = snake_case( type );

      var startSym = $interpolate.startSymbol();
      var endSym = $interpolate.endSymbol();
      var template = 
        '<div '+ directiveName +'-popup '+
          'title="'+startSym+'tt_title'+endSym+'" '+
          'content="'+startSym+'tt_content'+endSym+'" '+
          'placement="'+startSym+'tt_placement'+endSym+'" '+
          'animation="tt_animation" '+
          'is-open="tt_isOpen"'+
          '>'+
        '</div>';

      return {
        restrict: 'EA',
        scope: true,
        compile: function (tElem, tAttrs) {
          var tooltipLinker = $compile( template );

          return function link ( scope, element, attrs ) {
            var tooltip;
            var transitionTimeout;
            var popupTimeout;
            var appendToBody = angular.isDefined( options.appendToBody ) ? options.appendToBody : false;
            var triggers = getTriggers( undefined );
            var hasRegisteredTriggers = false;
            var hasEnableExp = angular.isDefined(attrs[prefix+'Enable']);

            var positionTooltip = function (){
              var position,
                ttWidth,
                ttHeight,
                ttPosition;
              // Get the position of the directive element.
              position = appendToBody ? $position.offset( element ) : $position.position( element );

              // Get the height and width of the tooltip so we can center it.
              ttWidth = tooltip.prop( 'offsetWidth' );
              ttHeight = tooltip.prop( 'offsetHeight' );

              // Calculate the tooltip's top and left coordinates to center it with
              // this directive.
              switch ( scope.tt_placement ) {
                case 'right':
                  ttPosition = {
                    top: position.top + position.height / 2 - ttHeight / 2,
                    left: position.left + position.width
                  };
                  break;
                case 'bottom':
                  ttPosition = {
                    top: position.top + position.height,
                    left: position.left + position.width / 2 - ttWidth / 2
                  };
                  break;
                case 'left':
                  ttPosition = {
                    top: position.top + position.height / 2 - ttHeight / 2,
                    left: position.left - ttWidth
                  };
                  break;
                default:
                  ttPosition = {
                    top: position.top - ttHeight,
                    left: position.left + position.width / 2 - ttWidth / 2
                  };
                  break;
              }

              ttPosition.top += 'px';
              ttPosition.left += 'px';

              // Now set the calculated positioning.
              tooltip.css( ttPosition );

            };

            // By default, the tooltip is not open.
            // TODO add ability to start tooltip opened
            scope.tt_isOpen = false;

            function toggleTooltipBind () {
              if ( ! scope.tt_isOpen ) {
                showTooltipBind();
              } else {
                hideTooltipBind();
              }
            }

            // Show the tooltip with delay if specified, otherwise show it immediately
            function showTooltipBind() {
              if(hasEnableExp && !scope.$eval(attrs[prefix+'Enable'])) {
                return;
              }
              if ( scope.tt_popupDelay ) {
                popupTimeout = $timeout( show, scope.tt_popupDelay, false );
                popupTimeout.then(function(reposition){reposition();});
              } else {
                show()();
              }
            }

            function hideTooltipBind () {
              scope.$apply(function () {
                hide();
              });
            }

            // Show the tooltip popup element.
            function show() {


              // Don't show empty tooltips.
              if ( ! scope.tt_content ) {
                return angular.noop;
              }

              createTooltip();

              // If there is a pending remove transition, we must cancel it, lest the
              // tooltip be mysteriously removed.
              if ( transitionTimeout ) {
                $timeout.cancel( transitionTimeout );
              }

              // Set the initial positioning.
              tooltip.css({ top: 0, left: 0, display: 'block' });

              // Now we add it to the DOM because need some info about it. But it's not 
              // visible yet anyway.
              if ( appendToBody ) {
                  $document.find( 'body' ).append( tooltip );
              } else {
                element.after( tooltip );
              }

              positionTooltip();

              // And show the tooltip.
              scope.tt_isOpen = true;
              scope.$digest(); // digest required as $apply is not called

              // Return positioning function as promise callback for correct
              // positioning after draw.
              return positionTooltip;
            }

            // Hide the tooltip popup element.
            function hide() {
              // First things first: we don't show it anymore.
              scope.tt_isOpen = false;

              //if tooltip is going to be shown after delay, we must cancel this
              $timeout.cancel( popupTimeout );

              // And now we remove it from the DOM. However, if we have animation, we 
              // need to wait for it to expire beforehand.
              // FIXME: this is a placeholder for a port of the transitions library.
              if ( scope.tt_animation ) {
                transitionTimeout = $timeout(removeTooltip, 500);
              } else {
                removeTooltip();
              }
            }

            function createTooltip() {
              // There can only be one tooltip element per directive shown at once.
              if (tooltip) {
                removeTooltip();
              }
              tooltip = tooltipLinker(scope, function () {});

              // Get contents rendered into the tooltip
              scope.$digest();
            }

            function removeTooltip() {
              if (tooltip) {
                tooltip.remove();
                tooltip = null;
              }
            }

            /**
             * Observe the relevant attributes.
             */
            attrs.$observe( type, function ( val ) {
              scope.tt_content = val;

              if (!val && scope.tt_isOpen ) {
                hide();
              }
            });

            attrs.$observe( prefix+'Title', function ( val ) {
              scope.tt_title = val;
            });

            attrs.$observe( prefix+'Placement', function ( val ) {
              scope.tt_placement = angular.isDefined( val ) ? val : options.placement;
            });

            attrs.$observe( prefix+'PopupDelay', function ( val ) {
              var delay = parseInt( val, 10 );
              scope.tt_popupDelay = ! isNaN(delay) ? delay : options.popupDelay;
            });

            var unregisterTriggers = function() {
              if (hasRegisteredTriggers) {
                element.unbind( triggers.show, showTooltipBind );
                element.unbind( triggers.hide, hideTooltipBind );
              }
            };

            attrs.$observe( prefix+'Trigger', function ( val ) {
              unregisterTriggers();

              triggers = getTriggers( val );

              if ( triggers.show === triggers.hide ) {
                element.bind( triggers.show, toggleTooltipBind );
              } else {
                element.bind( triggers.show, showTooltipBind );
                element.bind( triggers.hide, hideTooltipBind );
              }

              hasRegisteredTriggers = true;
            });

            var animation = scope.$eval(attrs[prefix + 'Animation']);
            scope.tt_animation = angular.isDefined(animation) ? !!animation : options.animation;

            attrs.$observe( prefix+'AppendToBody', function ( val ) {
              appendToBody = angular.isDefined( val ) ? $parse( val )( scope ) : appendToBody;
            });

            // if a tooltip is attached to <body> we need to remove it on
            // location change as its parent scope will probably not be destroyed
            // by the change.
            if ( appendToBody ) {
              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess () {
              if ( scope.tt_isOpen ) {
                hide();
              }
            });
            }

            // Make sure tooltip is destroyed and removed.
            scope.$on('$destroy', function onDestroyTooltip() {
              $timeout.cancel( transitionTimeout );
              $timeout.cancel( popupTimeout );
              unregisterTriggers();
              removeTooltip();
            });
          };
        }
      };
    };
  }];
})

.directive( 'tooltipPopup', function () {
  return {
    restrict: 'EA',
    replace: true,
    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-popup.html'
  };
})

.directive( 'tooltip', [ '$tooltip', function ( $tooltip ) {
  return $tooltip( 'tooltip', 'tooltip', 'mouseenter' );
}])

.directive( 'tooltipHtmlUnsafePopup', function () {
  return {
    restrict: 'EA',
    replace: true,
    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'
  };
})

.directive( 'tooltipHtmlUnsafe', [ '$tooltip', function ( $tooltip ) {
  return $tooltip( 'tooltipHtmlUnsafe', 'tooltip', 'mouseenter' );
}]);

/**
 * The following features are still outstanding: popup delay, animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html popovers, and selector delegatation.
 */
angular.module( 'ui.bootstrap.popover', [ 'ui.bootstrap.tooltip' ] )

.directive( 'popoverPopup', function () {
  return {
    restrict: 'EA',
    replace: true,
    scope: { title: '@', content: '@', placement: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/popover/popover.html'
  };
})

.directive( 'popover', [ '$tooltip', function ( $tooltip ) {
  return $tooltip( 'popover', 'popover', 'click' );
}]);

angular.module("template/pagination/pager.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/pagination/pager.html",
    "<ul class=\"pager\">\n" +
    "  <li ng-repeat=\"page in pages\" ng-class=\"{disabled: page.disabled, previous: page.previous, next: page.next}\"><a ng-click=\"selectPage(page.number)\">{{page.text}}</a></li>\n" +
    "</ul>");
}]);

angular.module("template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/pagination/pagination.html",
    "<ul class=\"pagination\">\n" +
    "  <li ng-repeat=\"page in pages\" ng-class=\"{active: page.active, disabled: page.disabled}\"><a ng-click=\"selectPage(page.number)\">{{page.text}}</a></li>\n" +
    "</ul>");
}]);

angular.module("template/tooltip/tooltip-html-unsafe-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tooltip/tooltip-html-unsafe-popup.html",
    "<div class=\"tooltip {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\" bind-html-unsafe=\"content\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tooltip/tooltip-popup.html",
    "<div class=\"tooltip {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/popover/popover.html",
    "<div class=\"popover {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" +
    "  <div class=\"arrow\"></div>\n" +
    "\n" +
    "  <div class=\"popover-inner\">\n" +
    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-show=\"title\"></h3>\n" +
    "      <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

(function(){
  var app = angular.module('countryApp', ['ngRoute', 'countryAppControllers', 'ui.bootstrap', 'mathFilters'], function($interpolateProvider) {
    $interpolateProvider.startSymbol('//');
    $interpolateProvider.endSymbol('//');
  });

  app.config(['$routeProvider', function($routeProvider) {
    $routeProvider.when('/details', {
        templateUrl: 'in_detail.html',
        controller: 'DetailsTabController',
        controllerAs: 'detailsCtrl',
        activeTab: 'details'
      })
      .when('/states', {
        templateUrl: 'states.html',
        controller: 'StatesTabController',
        controllerAs: 'statesCtrl',
        activeTab: 'states'
      })
      .when('/case-study', {
        templateUrl: 'case_study.html',
        controller: 'CaseStudyTabController',
        controllerAs: 'caseStudyCtrl',
        activeTab: 'case_study'
      })
      .otherwise({
        redirectTo: '/details'
      });
  }]);

  // Service to provide data. Uses a simple cache to avoid making
  // several requests.
  app.factory('CountryData', ['$http', function($http) {
    var cache;
    this.get = function(cb) {
      if (cache) {
        cb(cache);
      }
      else {
        var url = CS.domain + '/' + CS.lang + '/api/countries/' + CS.countryId + '.json';
        $http.get(url).success(function(data) {
          cache = data;
          cb(data);
        });
      }
    };
    return this;
  }]);


  // Module
  var countryAppControllers = angular.module('countryAppControllers', []);  

  // Controller for the navigation to activate the right tab.
  countryAppControllers.controller('CountryTabsController', ['$http', '$route', function($http, $route) {
    this.isActive = function(name) {
      return ($route.current) ? $route.current.activeTab == name : false;
    };
  }]);
  
  // Controller for the DETAILS TAB
  countryAppControllers.controller('DetailsTabController', ['$http', '$route', 'CountryData', function($http, $route, CountryData) {
    var _self = this;

    // Data.
    this.parameters = [];

    setupCommonTableMethods(_self);
    setupCommonParamDetailTableMethods(_self);

    CountryData.get(function(data) {
      _self.parameters = data.parameters;
    });
  }]);
  
  // Controller for the STATES TAB
  countryAppControllers.controller('StatesTabController', ['$http', '$route', '$location', 'CountryData', function($http, $route, $location, CountryData) {
    var _self = this;

    // If there are no states for the country redirect.
    if (!CS.countryHasStates) {
      $location.path('/details');
    }

    // Data
    this.states = [];

    setupCommonTableMethods(_self);

    this.getStateUrl = function(state) {
      var iso = state.iso.toLowerCase();
      return _self.getTranslatedUrl('state', iso);
    };

    CountryData.get(function(data) {
      _self.states = data.states;
      // Order states parameter array.
      angular.forEach(_self.states, function(state) {
        state.parameters.sort(function(a, b) {
          return a.id > b.id;
        });
      });
    });

  }]);
  
  // Controller for the CASE STUDY TAB
  countryAppControllers.controller('CaseStudyTabController', ['$http', '$route', function($http, $route) {
    // code;
  }]);

})();

(function(){
  var app = angular.module('countryListApp', ['ui.bootstrap', 'mathFilters'], function($interpolateProvider) {
    $interpolateProvider.startSymbol('//');
    $interpolateProvider.endSymbol('//');
  });

  app.controller('CountryListController', ['$http', function($http) {
    var _self = this;
    // Data
    this.countries = [];
    
    setupCommonTableMethods(_self);
    
    // Helper function.
    var getRequestUrl = function(regionId) {
      regionId = regionId || null;

      if (regionId == null) {
        return CS.domain + '/' + CS.lang + '/api/countries.json';
      }
      else {
        return CS.domain + '/' + CS.lang + '/api/regions/' + regionId + '.json';
      }
    };
    // Order the parameter array in countries and states.
    var orderParamsArray = function() {
      angular.forEach(_self.countries, function(country) {
        country.parameters.sort(function(a, b) {
          return a.id > b.id;
        });
        angular.forEach(country.states, function(state) {
          state.parameters.sort(function(a, b) {
            return a.id > b.id;
          });
        });
      });
    };

    this.getCountryUrl = function(country) {
      var iso = country.iso.toLowerCase();
      return _self.getTranslatedUrl('country', iso);
    };
    
    this.getStateUrl = function(state) {
      var iso = state.iso.toLowerCase();
      return _self.getTranslatedUrl('state', iso);
    };

    this.toggleStates = function($event) {
      var tbody = jQuery($event.target).closest('tbody');
      var statesRow = tbody.find('.country-states');
      if (statesRow.is(':hidden')) {
        tbody.addClass('open');
        statesRow.trSlideDown();
      }
      else {
        tbody.removeClass('open');
        statesRow.trSlideUp();
      }
    };

    // ---- Logic ----

    if (CS.regionId) {
      $http.get(getRequestUrl(CS.regionId)).success(function(data) {
        _self.countries = data.countries;
        // Order data once available.
        orderParamsArray();
      });
    }
    else {
      $http.get(getRequestUrl()).success(function(data) {
        _self.countries = data;
        // Order data once available.
        orderParamsArray();
      });
    }

  }]);
})();
(function(){
  var app = angular.module('parameterApp', ['mathFilters', 'ui.bootstrap'], function($interpolateProvider) {
    $interpolateProvider.startSymbol('//');
    $interpolateProvider.endSymbol('//');
  });

  app.controller('CountryListController', ['$http', function($http) {
    var _self = this;
    // Data
    this.parameter = {};
    this.countries = [];
    this.scoreAvg = 0;

    setupCommonTableMethods(_self);

    // Override sortfield
    this.sortField = 'data[0].value';

    var calcAvgScore = function() {
      var score = 0;
      angular.forEach(_self.countries, function(country) {
        score += country.data[0].value;
      });
      _self.scoreAvg = score / _self.countries.length;
    };

    this.getCountryUrl = function(country) {
      var iso = country.iso.toLowerCase();
      return _self.getTranslatedUrl('country', iso);
    };

    // Override function to only have one parameter.
    this.getTooltipContent = function(data) {
      var t = '<dl class="params-legend">';
      var className = 'param-' + _self.parameter.id;
      t += '<dt class="' + className + '">';
      t += _self.parameter.name;
      t += '</dt>';
      t += '<dd>';
      t += round(data.value, 2);
      t += '<small>';
      // 0.29 * 100 = 28.999999999999
      // Round to solve the problem.
      t += round(_self.parameter.weight * 100, 2) + '%';
      t += '</small>';
      t += '</dd>';
      t += '</dl>';

      return t;
    };

    // ---- Logic ----
    var url = CS.domain + '/' + CS.lang + '/api/parameters/' + CS.parameterId + '.json';
    $http.get(url).success(function(data) {

      // Order parameter data array and country score
      // so we don't need to search the value every time.
      angular.forEach(data.countries, function(country) {
        country.data.sort(function(a, b) {
          return b.year - a.year;
        });
        country.score.sort(function(a, b) {
          return b.year - a.year;
        });
      });

      _self.parameter = data;
      _self.countries = data.countries;
      calcAvgScore();
    });

  }]);
})();

(function() {

  CS.policyProxy = 'http://146.185.136.6/climatescope/';

  // All the results from the API come in object format.
  // Repeats can't be sorted when looping over objects
  // Since we don't need the object key, we can safely
  // convert to array.
  // Another approach: http://justinklemm.com/angularjs-filter-ordering-objects-ngrepeat/
  var objToArray = function(obj) {
    var arr = [];
    angular.forEach(obj, function(value) {
      arr.push(value);
    });
    return arr;
  };

  // When switching languages the url must reflect the current one
  // otherwise the page will not load properly.
  var updateLangSwitcherUrl = function(new_url) {
    $('.lang-menu a').each(function() {
      var url;
      // If the original url is set return it.
      if ($(this).data('orig_href')) {
        url = $(this).data('orig_href');
      }
      // Otherwise store it and return the href value.
      else {
        url = $(this).attr('href');
        $(this).data('orig_href', url);
      }
      url += '#' + new_url;
      $(this).attr('href', url);
    });
  };

  var app = angular.module('policyApp', ['ngRoute', 'ui.bootstrap'], function($interpolateProvider) {
    $interpolateProvider.startSymbol('%%');
    $interpolateProvider.endSymbol('%%');
  });

  app.filter('nl2br', ['$sce', function($sce) {
    return function(msg, is_xhtml) {
      var is_xhtml = is_xhtml || true;
      var breakTag = (is_xhtml) ? '<br />' : '<br>';
      var msg = (msg + '').replace(/([^>\r\n]?)(\r\n|\n\r|\r|\n)/g, '$1' + breakTag + '$2');
      return $sce.trustAsHtml(msg);
    };
  }]);

  app.config(['$routeProvider', function($routeProvider) {
    $routeProvider.when('/', {
      templateUrl : 'policy_list.html',
      controller : 'policyListController',
      controllerAs : 'policyListCtrl',
      reloadOnSearch : false
    }).when('/policy/:policyId', {
      templateUrl : 'policy.html',
      controller : 'policyController',
      controllerAs : 'policyCtrl'
    }).otherwise({
      redirectTo : '/'
    });
  }]);
  
  app.directive("initDropdown", function() {
    return {
      restrict: 'AE',
      link: function () {
        console.log('asdasd');
        initDropdown();
      }
    };
  });
  
  app.factory('queryStringData', ['$location', function($location) {
    var _self = this;

    this.filters = {
      country : null,
      status : null,
      //subsector: null,
      state : null
    };

    this.pagination = {
      page: null
    };

    this.sort = {
      'sort-on': 'name',
      'sort-direction': 'asc'
    };

    this.disableFilters = function() {
      // Set every filter to null.
      for (var key in _self.filters) {
        _self.filters[key] = null;
      }
      _self.update();
    };

    this.areFiltersEnabled = function() {
      var control = false;
      angular.forEach(_self.filters, function(value) {
        if (value != null) control = true;
      });
      return control;
    };

    this.setSort = function(field) {
      _self.sort['sort-on'] = field;
      _self.sort['sort-direction'] = _self.sort['sort-direction'] == 'asc' ? 'desc' : 'asc';
      _self.update();
    };

    this.update = function() {
      var queryString = {};
      angular.extend(queryString, _self.filters, _self.pagination, _self.sort);
      $location.search(queryString);
    };

    // Check if there are filters in the url.
    if (!angular.equals({}, $location.search())) {
      // Update language switcher url.
      updateLangSwitcherUrl($location.url());

      // Set already preset filters.
      var data = $location.search();
      for (var key in _self.filters) {
        _self.filters[key] = data[key] || null;
      }

      // Both the status and subsector have numeric values
      // but when they come from the url they are string.
      // They must be converted to integers in order to work.
      if (_self.filters.status) {
        _self.filters.status = parseInt(_self.filters.status);
      }
      // if (_self.filters.subsector) {
      //   _self.filters.subsector = parseInt(_self.filters.subsector);
      // }

      // Set already preset pagination.
      for (var key in _self.pagination) {
        _self.pagination[key] = data[key] || null;
      }

      // Set already preset sort.
      for (var key in _self.sort) {
        _self.sort[key] = data[key] || null;
      }
    }

    return this;
  }]);

  app.controller('policyListController', function() {});

  app.controller('policyFiltersController', ['$http', '$filter', '$rootScope', '$location', 'queryStringData', function($http, $filter, $rootScope, $location, queryStringData) {
    var _self = this;

    this.filterData = {};
    this.filters = queryStringData.filters;
    this.filtersEnabled = queryStringData.areFiltersEnabled();

    // Get the ordered options.
    // This could be done in the html but it's more organised like this.
    this.getSelectOpts = function(field) {
      var data = objToArray(field);
      return $filter('orderBy')(data, 'name');
    };

    // Get the filtered options.
    // This could be done in the html but it's more organised like this.
    this.getSelectOptsState = function(field) {
      var data = objToArray(field);
      var filtered = $filter('filter')(data, { countryId : _self.filters.country || null });
      return $filter('orderBy')(filtered, 'name');
    };

    this.disableFilters = function() {
      if (!_self.filtersEnabled) return;
      
      _self.filtersEnabled = false;
      queryStringData.disableFilters();
      
      $rootScope.$broadcast('apply-filters', _self.filters);
    };

    this.apply = function() {
      // Check if filters are enabled.
      _self.filtersEnabled = queryStringData.areFiltersEnabled();
      queryStringData.update();

      $rootScope.$broadcast('apply-filters', _self.filters);
    };

    $http.get(CS.policyProxy + 'policy/filter').success(function(data) {
      _self.filterData = data;
    });

    $rootScope.$on('$locationChangeSuccess', function() {
      updateLangSwitcherUrl($location.url());
    });

  }]);

  app.controller('policyTableController', ['$http', '$scope', '$location', '$templateCache', 'queryStringData', function($http, $scope, $location, $templateCache, queryStringData) {
    var _self = this;

    // Override pagination template.
    $templateCache.put("template/pagination/pagination.html",
      "<div class='pagination-wrapper'>\n" +
      "  <ul class='pagination bttn-group bttn-group-s bttn-list'>\n" +
      "    <li ng-repeat='page in pages'><a class='bttn bttn-default' ng-class='{active: page.active, disabled: page.disabled}' ng-click='selectPage(page.number)'>{{page.text}}</a></li>\n" +
      "  </ul>\n" +
      "</div>");

    this.filters = queryStringData.filters;
    this.sort = queryStringData.sort;
    this.policies = {};

    this.loadingData = true;

    // Pagination.
    this.currentPage = queryStringData.pagination.page || 1;
    this.totalItems = 0;
    this.itemsPerPage = 50;
    // Pages to show in the pager.
    this.pagesToShow = 5;

    // Sort default.
    this.sort = queryStringData.sort;

    this.setSort = function(field) {
      queryStringData.setSort(field);
      getPolicies();
    };

    this.checkSortClasses = function(field) {
      if (_self.sort['sort-on'] != field) {
        return 'sort-none';
      }
      else if (_self.sort['sort-direction'] == 'desc') {
        return 'sort-desc';
      }
      else {
        return 'sort-asc';
      }
    };

    this.getPolicyLink = function(policy) {
      return '#/policy/' + policy.id;
    };

    // List of stuff to show in the tooltip.
    this.getTooltipContentList = function(list) {
      var data = [];
      for (var i in list) {
        // The first element is already printed.
        if (i == 0) continue;
        data.push(list[i].name);
      }
      return data.join(', ');
    };

    this.changePage = function(page) {
      _self.currentPage = page;
      // Update query string.
      queryStringData.pagination.page = page;
      queryStringData.update();
      // Reload policies.
      getPolicies();
    };

    var getPolicies = function() {
      _self.loadingData = true;

      var queryString = [];
      // Pagination.
      queryString.push('limit=' + _self.itemsPerPage);
      queryString.push('offset=' + ((_self.currentPage - 1) * _self.itemsPerPage));

      // Filters.
      angular.forEach(_self.filters, function(value, key) {
        if (value !== null) {
          queryString.push(key + '=' + value);
        }
      });
      
      // Sort.
      angular.forEach(_self.sort, function(value, key) {
        if (value !== null) {
          queryString.push(key + '=' + value);
        }
      });

      if (queryString.length) {
        queryString = '?' + queryString.join('&');
      } else {
        queryString = '';
      }

      $http.get(CS.policyProxy + 'policy' + queryString).success(function(data) {
        _self.policies = objToArray(data.listData);
        _self.totalItems = data.metaData.totalResults;
        _self.loadingData = false;
      });
    };

    $scope.$on('apply-filters', function(event, filters) {
      _self.loadingData = true;
      getPolicies();
    });

    getPolicies();
  }]);

  app.controller('policyController', ['$http', '$routeParams', '$location', function($http, $routeParams, $location) {
    // Update language switcher url.
    updateLangSwitcherUrl($location.url());

    var _self = this;
    this.policy = {};

    this.loadingData = true;

    $http.get(CS.policyProxy + 'policy/' + $routeParams.policyId).success(function(data) {
      _self.policy = data;
      _self.loadingData = false;
    });
  }]);

})(); 
(function(){
  var app = angular.module('stateApp', ['ui.bootstrap', 'mathFilters'], function($interpolateProvider) {
    $interpolateProvider.startSymbol('//');
    $interpolateProvider.endSymbol('//');
  });
  
  // Controller for the DETAILS
  app.controller('DetailsController', ['$http', function($http) {
    var _self = this;

    // Data.
    this.parameters = [];

    setupCommonTableMethods(_self);
    setupCommonParamDetailTableMethods(_self);
    
    var url = CS.domain + '/' + CS.lang + '/api/countries/' + CS.stateId + '.json';
    $http.get(url).success(function(data) {
      _self.parameters = data.parameters;
    });
  }]);

})();

/**
 * Common methods used in the table related controllers.
 * Modifies the scope object
 * @param {Object} scope
 */
function setupCommonTableMethods(scope) {
  // Sort default.
  scope.sortField = 'score';
  scope.sortReverse = true;
  
  scope.setSort = function(field) {
    scope.sortField = field;
    scope.sortReverse = !scope.sortReverse;
  };
  
  scope.checkSortClasses = function(field) {
    if (scope.sortField != field) {
      return 'sort-none';
    }
    if (scope.sortReverse === true) {
      return 'sort-desc';
    }
    else {
      return 'sort-asc';
    }
  };

  scope.calcBarSegment = function(param) {
    weight = param.weight != null ? param.weight : 0.25;
    return ( param.value * weight * (100/5) ) + '%';
  };
  
  scope.getTranslatedUrl = function(subject, id) {
    switch(subject) {
      case 'country':
        return (CS.countryIndex) ? CS.countryIndex[id] : '';
      break;
      case 'state':
        return (CS.stateIndex) ? CS.stateIndex[id] : '';
      break;
      case 'parameter':
        return (CS.parameterIndex) ? CS.parameterIndex[id] : '';
      break;
      default:
        return '';
      break;
    }
  };
  
  scope.getTooltipContent = function(params) {
    var t = '<dl class="params-legend">';
    angular.forEach(params, function(param) {
      var className = 'param-' + param.id;
      t += '<dt class="' + className + '">';
      t += param.name;
      t += '</dt>';
      t += '<dd>';
      t += round(param.value, 2);
      t += '<small>';
      // 0.29 * 100 = 28.999999999999
      // Round to solve the problem.
      t += round(param.weight * 100, 2) + '%';
      t += '</small>';
      t += '</dd>';
    });
    t += '</dl>';
    
    return t;
  };
};

/**
 * Common methods used in the parameter Details table
 * Modifies the scope object
 * @param {Object} scope
 */
function setupCommonParamDetailTableMethods(scope) {
  scope.getParamUrl = function(param) {
    return scope.getTranslatedUrl('parameter', param.id);
  };
  
  scope.getTooltipContent = function(ind) {
    return [
      '<h6>' + ind.name + '</h6>',
      '<p>Parameter description will go here.</p>'
    ].join('');
  };
}
(function(){
  
  var mathFilters = angular.module('mathFilters', []);
  
  mathFilters.filter('round', function() {
    return function(input, precision) {
      return round(input, precision);
    };
  });
  
})();
(function(a){function q(d){return"number"===typeof d&&!isNaN(d)&&isFinite(d)}function s(d,g){return 100*g/(d[1]-d[0])}function p(d,g){for(var e=1;d>=g[e];)e+=1;return e}function k(d,g,e,a){this.xPct=[];this.xVal=[];this.xSteps=[a||!1];this.xNumSteps=[!1];this.snap=g;this.direction=e;for(var f in d)if(d.hasOwnProperty(f)){g=f;e=d[f];a=void 0;"number"===typeof e&&(e=[e]);if("[object Array]"!==Object.prototype.toString.call(e))throw Error("noUiSlider: 'range' contains invalid value.");a="min"===g?0:
"max"===g?100:parseFloat(g);if(!q(a)||!q(e[0]))throw Error("noUiSlider: 'range' value isn't numeric.");this.xPct.push(a);this.xVal.push(e[0]);a?this.xSteps.push(isNaN(e[1])?!1:e[1]):isNaN(e[1])||(this.xSteps[0]=e[1])}this.xNumSteps=this.xSteps.slice(0);for(f in this.xNumSteps)this.xNumSteps.hasOwnProperty(f)&&(d=Number(f),(g=this.xNumSteps[f])&&(this.xSteps[d]=s([this.xVal[d],this.xVal[d+1]],g)/(100/(this.xPct[d+1]-this.xPct[d]))))}k.prototype.getMargin=function(d){return 2===this.xPct.length?s(this.xVal,
d):!1};k.prototype.toStepping=function(d){var g=this.xVal,a=this.xPct;if(d>=g.slice(-1)[0])d=100;else{var m=p(d,g),f,k;f=g[m-1];k=g[m];g=a[m-1];a=a[m];f=[f,k];d=s(f,0>f[0]?d+Math.abs(f[0]):d-f[0]);d=g+d/(100/(a-g))}this.direction&&(d=100-d);return d};k.prototype.fromStepping=function(d){this.direction&&(d=100-d);var a;var e=this.xVal;a=this.xPct;if(100<=d)a=e.slice(-1)[0];else{var m=p(d,a),f,k;f=e[m-1];k=e[m];e=a[m-1];f=[f,k];a=100/(a[m]-e)*(d-e)*(f[1]-f[0])/100+f[0]}d=Math.pow(10,7);return Number((Math.round(a*
d)/d).toFixed(7))};k.prototype.getStep=function(d){this.direction&&(d=100-d);var a=this.xPct,e=this.xSteps,k=this.snap;if(100!==d){var f=p(d,a);k?(e=a[f-1],a=a[f],d=d-e>(a-e)/2?a:e):(e[f-1]?(k=a[f-1],e=e[f-1],a=Math.round((d-a[f-1])/e)*e,a=k+a):a=d,d=a)}this.direction&&(d=100-d);return d};k.prototype.getApplicableStep=function(a){var g=p(a,this.xPct);a=100===a?2:1;return[this.xNumSteps[g-2],this.xVal[g-a],this.xNumSteps[g-a]]};k.prototype.convert=function(a){return this.getStep(this.toStepping(a))};
a.noUiSlider={Spectrum:k}})(window.jQuery||window.Zepto);(function(a){function q(c){return"number"===typeof c&&!isNaN(c)&&isFinite(c)}function s(c,b){if(!q(b))throw Error("noUiSlider: 'step' is not numeric.");c.singleStep=b}function p(c,b){if("object"!==typeof b||a.isArray(b))throw Error("noUiSlider: 'range' is not an object.");if(void 0===b.min||void 0===b.max)throw Error("noUiSlider: Missing 'min' or 'max' in 'range'.");c.spectrum=new a.noUiSlider.Spectrum(b,c.snap,c.dir,c.singleStep)}function k(c,b){var d=b;b=a.isArray(d)?d:[d];if(!a.isArray(b)||!b.length||
2<b.length)throw Error("noUiSlider: 'start' option is incorrect.");c.handles=b.length;c.start=b}function d(c,b){c.snap=b;if("boolean"!==typeof b)throw Error("noUiSlider: 'snap' option must be a boolean.");}function g(c,b){c.animate=b;if("boolean"!==typeof b)throw Error("noUiSlider: 'animate' option must be a boolean.");}function e(c,b){if("lower"===b&&1===c.handles)c.connect=1;else if("upper"===b&&1===c.handles)c.connect=2;else if(!0===b&&2===c.handles)c.connect=3;else if(!1===b)c.connect=0;else throw Error("noUiSlider: 'connect' option doesn't match handle count.");
}function m(c,b){switch(b){case "horizontal":c.ort=0;break;case "vertical":c.ort=1;break;default:throw Error("noUiSlider: 'orientation' option is invalid.");}}function f(c,b){if(!q(b))throw Error("noUiSlider: 'margin' option must be numeric.");c.margin=c.spectrum.getMargin(b);if(!c.margin)throw Error("noUiSlider: 'margin' option is only supported on linear sliders.");}function x(c,b){if(!q(b))throw Error("noUiSlider: 'limit' option must be numeric.");c.limit=c.spectrum.getMargin(b);if(!c.limit)throw Error("noUiSlider: 'limit' option is only supported on linear sliders.");
}function y(c,b){switch(b){case "ltr":c.dir=0;break;case "rtl":c.dir=1;c.connect=[0,2,1,3][c.connect];break;default:throw Error("noUiSlider: 'direction' option was not recognized.");}}function t(c,b){if("string"!==typeof b)throw Error("noUiSlider: 'behaviour' must be a string containing options.");var a=0<=b.indexOf("tap"),d=0<=b.indexOf("drag"),e=0<=b.indexOf("fixed"),f=0<=b.indexOf("snap");c.events={tap:a||f,drag:d,fixed:e,snap:f}}function u(c,b){c.format=b;if("function"===typeof b.to&&"function"===
typeof b.from)return!0;throw Error("noUiSlider: 'format' requires 'to' and 'from' methods.");}var h={to:function(c){return c.toFixed(2)},from:Number};a.noUiSlider.testOptions=function(c){var b={margin:0,limit:0,animate:!0,format:h},G;G={step:{r:!1,t:s},start:{r:!0,t:k},connect:{r:!0,t:e},direction:{r:!0,t:y},snap:{r:!1,t:d},animate:{r:!1,t:g},range:{r:!0,t:p},orientation:{r:!1,t:m},margin:{r:!1,t:f},limit:{r:!1,t:x},behaviour:{r:!0,t:t},format:{r:!1,t:u}};c=a.extend({connect:!1,direction:"ltr",behaviour:"tap",
orientation:"horizontal"},c);a.each(G,function(a,d){if(void 0===c[a]){if(d.r)throw Error("noUiSlider: '"+a+"' is required.");return!0}d.t(b,c[a])});b.style=b.ort?"top":"left";return b}})(window.jQuery||window.Zepto);(function(a){function q(c){return Math.max(Math.min(c,100),0)}function s(c,b,a){c.addClass(b);setTimeout(function(){c.removeClass(b)},a)}function p(c,b){var d=a("<div><div/></div>").addClass(h[2]),e=["-lower","-upper"];c&&e.reverse();d.children().addClass(h[3]+" "+h[3]+e[b]);return d}function k(a,b,d){switch(a){case 1:b.addClass(h[7]);d[0].addClass(h[6]);break;case 3:d[1].addClass(h[6]);case 2:d[0].addClass(h[7]);case 0:b.addClass(h[6])}}function d(a,b,d){var e,f=[];for(e=0;e<a;e+=1)f.push(p(b,e).appendTo(d));
return f}function g(c,b,d){d.addClass([h[0],h[8+c],h[4+b]].join(" "));return a("<div/>").appendTo(d).addClass(h[1])}function e(c,b,e){function f(){return v[["width","height"][b.ort]]()}function m(b){var a,c=[n.val()];for(a=0;a<b.length;a+=1)n.trigger(b[a],c)}function p(a){return 1===a.length?a[0]:b.dir?a.reverse():a}function x(b){return function(a,c){n.val([b?null:c,b?c:null],!0)}}function t(b){var c=a.inArray(b,w);n[0].linkAPI&&n[0].linkAPI[b]&&n[0].linkAPI[b].change(B[c],l[c].children(),n)}function C(a,
c,d){var e=a[0]!==l[0][0]?1:0,H=r[0]+b.margin,f=r[1]-b.margin,g=r[0]+b.limit,k=r[1]-b.limit;1<l.length&&(c=e?Math.max(c,H):Math.min(c,f));!1!==d&&b.limit&&1<l.length&&(c=e?Math.min(c,g):Math.max(c,k));c=z.getStep(c);c=q(parseFloat(c.toFixed(7)));if(c===r[e])return!1;a.css(b.style,c+"%");a.is(":first-child")&&a.toggleClass(h[17],50<c);r[e]=c;B[e]=z.fromStepping(c);t(w[e]);return!0}function A(a,c,d,e){a=a.replace(/\s/g,".nui ")+".nui";return c.on(a,function(a){if(n.attr("disabled")||n.hasClass(h[14]))return!1;
a.preventDefault();var c=0===a.type.indexOf("touch"),f=0===a.type.indexOf("mouse"),E=0===a.type.indexOf("pointer"),D,g,k=a;0===a.type.indexOf("MSPointer")&&(E=!0);a.originalEvent&&(a=a.originalEvent);c&&(D=a.changedTouches[0].pageX,g=a.changedTouches[0].pageY);if(f||E)E||void 0!==window.pageXOffset||(window.pageXOffset=document.documentElement.scrollLeft,window.pageYOffset=document.documentElement.scrollTop),D=a.clientX+window.pageXOffset,g=a.clientY+window.pageYOffset;k.points=[D,g];k.cursor=f;a=
k;a.calcPoint=a.points[b.ort];d(a,e)})}function I(a,b){var c=b.handles||l,d,e=!1,e=100*(a.calcPoint-b.start)/f(),g=c[0][0]!==l[0][0]?1:0;var h=b.positions;d=e+h[0];e+=h[1];1<c.length?(0>d&&(e+=Math.abs(d)),100<e&&(d-=e-100),d=[q(d),q(e)]):d=[d,e];e=C(c[0],d[g],1===c.length);1<c.length&&(e=C(c[1],d[g?0:1],!1)||e);e&&m(["slide"])}function J(b){a("."+h[15]).removeClass(h[15]);b.cursor&&a("body").css("cursor","").off(".nui");y.off(".nui");n.removeClass(h[12]);m(["set","change"])}function F(b,c){1===c.handles.length&&
c.handles[0].children().addClass(h[15]);b.stopPropagation();A(u.move,y,I,{start:b.calcPoint,handles:c.handles,positions:[r[0],r[l.length-1]]});A(u.end,y,J,null);b.cursor&&(a("body").css("cursor",a(b.target).css("cursor")),1<l.length&&n.addClass(h[12]),a("body").on("selectstart.nui",!1))}function K(c){var d=c.calcPoint,e=0;c.stopPropagation();a.each(l,function(){e+=this.offset()[b.style]});e=d<e/2||1===l.length?0:1;d-=v.offset()[b.style];d=100*d/f();b.events.snap||s(n,h[14],300);C(l[e],d);m(["slide",
"set","change"]);b.events.snap&&F(c,{handles:[l[e]]})}var n=a(c),r=[-1,-1],v,l,z=b.spectrum,B=[],w=["lower","upper"].slice(0,b.handles);b.dir&&w.reverse();c.LinkUpdate=t;c.LinkConfirm=function(c,d){var e=a.inArray(c,w);d&&d.appendTo(l[e].children());b.dir&&(e=1===e?0:1);return x(e)};c.LinkDefaultFormatter=b.format;c.LinkDefaultFlag="lower";c.reappend=function(){var a,b;for(a=0;a<w.length;a+=1)this.linkAPI&&this.linkAPI[b=w[a]]&&this.linkAPI[b].reconfirm(b)};if(n.hasClass(h[0]))throw Error("Slider was already initialized.");
v=g(b.dir,b.ort,n);l=d(b.handles,b.dir,v);k(b.connect,n,l);(function(a){var b;if(!a.fixed)for(b=0;b<l.length;b+=1)A(u.start,l[b].children(),F,{handles:[l[b]]});a.tap&&A(u.start,v,K,{handles:l});a.drag&&(b=v.find("."+h[7]).addClass(h[10]),a.fixed&&(b=b.add(v.children().not(b).children())),A(u.start,b,F,{handles:l}))})(b.events);c.vSet=function(c){if(n[0].LinkIsEmitting)return this;var d;c=a.isArray(c)?c:[c];b.dir&&1<b.handles&&c.reverse();b.animate&&-1!==r[0]&&s(n,h[14],300);d=1<l.length?3:1;1===c.length&&
(d=1);var e,f,g;b.limit&&(d+=1);for(e=0;e<d;e+=1)f=e%2,g=c[f],null!==g&&!1!==g&&("number"===typeof g&&(g=String(g)),g=b.format.from(g),(!1===g||isNaN(g)||!1===C(l[f],z.toStepping(g),e===3-b.dir))&&t(w[f]));m(["set"]);return this};c.vGet=function(){var a,c=[];for(a=0;a<b.handles;a+=1)c[a]=b.format.to(B[a]);return p(c)};c.destroy=function(){a(this).off(".nui").removeClass(h.join(" ")).empty();delete this.LinkUpdate;delete this.LinkConfirm;delete this.LinkDefaultFormatter;delete this.LinkDefaultFlag;
delete this.reappend;delete this.vGet;delete this.vSet;delete this.getCurrentStep;delete this.getInfo;delete this.destroy;return e};c.getCurrentStep=function(){var b=a.map(r,function(a,b){var c=z.getApplicableStep(a);return[[B[b]-c[2]>=c[1]?c[2]:c[0],c[2]]]});return p(b)};c.getInfo=function(){return[z,b.style,b.ort]};n.val(b.start)}function m(c){if(!this.length)throw Error("noUiSlider: Can't initialize slider on empty selection.");var b=a.noUiSlider.testOptions(c,this);return this.each(function(){e(this,
b,c)})}function f(c){return this.each(function(){if(this.destroy){var b=a(this).val(),d=this.destroy(),e=a.extend({},d,c);a(this).noUiSlider(e);this.reappend();d.start===e.start&&a(this).val(b)}else a(this).noUiSlider(c)})}function x(){return this[0][arguments.length?"vSet":"vGet"].apply(this[0],arguments)}var y=a(document),t=a.fn.val,u=window.navigator.pointerEnabled?{start:"pointerdown",move:"pointermove",end:"pointerup"}:window.navigator.msPointerEnabled?{start:"MSPointerDown",move:"MSPointerMove",
end:"MSPointerUp"}:{start:"mousedown touchstart",move:"mousemove touchmove",end:"mouseup touchend"},h="noUi-target noUi-base noUi-origin noUi-handle noUi-horizontal noUi-vertical noUi-background noUi-connect noUi-ltr noUi-rtl noUi-dragable  noUi-state-drag  noUi-state-tap noUi-active  noUi-stacking".split(" ");a.fn.val=function(){var c=arguments,b=a(this[0]);return arguments.length?this.each(function(){(a(this).hasClass(h[0])?x:t).apply(a(this),c)}):(b.hasClass(h[0])?x:t).call(b)};a.fn.noUiSlider=
function(a,b){return(b?f:m).call(this,a)}})(window.jQuery||window.Zepto);

/*! jquery-once - v1.2.6 - 9/11/2013 - http://github.com/robloach/jquery-once
 * (c) 2013 Rob Loach (http://robloach.net)
 * Licensed GPL-2.0, MIT */
(function(e){"use strict";"object"==typeof exports?e(require("jquery")):"function"==typeof define&&define.amd?define(["jquery"],e):e(jQuery)})(function(e){"use strict";var n={},t=0;e.fn.once=function(r,i){"string"!=typeof r&&(r in n||(n[r]=++t),i||(i=r),r="jquery-once-"+n[r]);var o=r+"-processed",s=this.not("."+o).addClass(o);return e.isFunction(i)?s.each(i):s},e.fn.removeOnce=function(n,t){var r=n+"-processed",i=this.filter("."+r).removeClass(r);return e.isFunction(t)?i.each(t):i}});